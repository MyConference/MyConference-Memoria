\chapter{Aplicación Móvil}
\label{chap:android}

\begin{figure}[h]
  \centering
  \includegraphics[width=0.6\textwidth]{./Imagenes/Bitmap/diagrama-android}
  \caption{Diagrama de la arquitectura relevante a la aplicación android}
  \label{fig:diagram-android}
\end{figure}

Para mostrar toda la información sobre los congresos se ha creado una aplicación para dispositivos móviles con Android. En este capítulo se habla sobre él y su entorno, así como de la estructura y de las características de nuestra aplicación para \textit{My Conference}.

La figura \ref{fig:diagram-android} muestra cómo interactúa la aplicación móvil con el resto del sistema.

\section{Android}

Android \cite{Android} es la plataforma móvil más popular del mundo. Se encuentra en cientos de millones de dispositivos en más de 190 países alrededor del mundo. Es la plataforma móvil base más extendida y crece muy rápido -- cada día otro millón de usuarios enciende por primera vez su nuevo dispositivo Android y se inicia en el mundo de las apps, los juegos y demás contenido digital.

Además, Android ofrece la capacidad de crear apps y juegos para gente de todas partes del mundo y distribuirlas instantáneamente a través de su tienda abierta a todo el mundo.

Hemos decidido usar Android principalmente por las siguientes razones:

\begin{itemize}
    \item{\textbf{Alizanza mundial y una gran base}}

Construído gracias al aporte de la comunidad de código abierto de Linux y con más de 300 asociados hardware, software y móviles, Android se ha convertido en el sistema operativo con un crecimiento mayor.

Que sea de código abierto lo ha convertido en el favorito tanto para usuarios como para desarrolladores, creciendo rápidamente el consumo de apps. Los usuarios de Android se descargan más de 1.5 billones de apps y juegos de la Google Play cada mes.

Con la ayuda de sus aliados, Android intenta superar los límites hardware y software para llevar al usuario final y a los desarrolladores una experiencia única llena de posibilidades. Y para los desarrolladores en concreto, la innovación de Android hace que puedan diseñar apps que se diferencien del resto, usando para ello las tecnologías más avanzadas.

    \item{\textbf{Framework de desarrollo potente}}

Android ofrece todas las herramientas para crear las mejores apps. A partir de un modelo simple permite desplegar las apps a lo largo y ancho del mundo y para una gran cantidad de dispositivos -- desde móviles hasta tablets, y más.

Android también permite diseñar apps agradables a la vista y que aprovechen todas las capacidades hardware de las que dispone cada dispositivo. Se adapta automáticamente a la interfaz gráfica para que se vea lo mejor posible en cada dispositivo y te da tanto control como sea necesario para configurar cada tipo de dispositivo. Por ejemplo, se puede crear una app que esté optimizada tanto para móviles como para tablets. La interfaz gráfica se crea a partir de simples y ligeros archivos XML, unos para las partes comunes de todos los dispositivos y otros para las partes específicas de móviles o tablets. Y en tiempo de ejecución es Android el encargado de seleccionar los archivos necesarios basándose en el tamaño de la pantalla, la densidad, la localización y más parámetros.

Para ayudar a los desarrolladores, Android ofrece el paquete llamado \textit{Android Developer Tools}, que es un entorno de desarrollo integrado Java con todo tipo de funcionalidades para crear, debuggear y terminar todo el proceso antes de publicar una app. Usándo este IDE se puede desarrollar para cualquier dispositivo Android existente y utilizar máquinas virtuales para recrear cualquier funcionalidad hardware presente en estos dispositivos.

    \item{\textbf{Un mercado libre para distribuir tus apps}}

Google Play es el mercado principal para vender y distribuir apps de Android. Cuando publicas una app, llegas a todos los rincones de Android.

Como mercado abierto, tu tienes el control de cómo quieres vender tu producto. Se puede publicar cuando se quiera, tantas veces como se quiera, y llegar al público que se quiera. Se puede publicar para todo el mundo o enfocarse en un sector más pequeño, en una serie de dispositivos o solo interesarse por dispostivos con ciertas capacidades harware.

Se pueden monetizar las apps de la forma que se crea mejor -- apps de pago o gratis, con publicidad dentro de la app o con contenido descargable. También se tiene el control del precio que se pone a una app o a los contenidos descargables desde la misma, y se pueden cambiar esos precios siempre que se quiera.

Google Play también te ayuda a tener mayor visibilidad dentro del mercado. A medida que una app gana popularidad, se le reservan sitios estratégicos dentro del mercado y se coloca en el \textit{top ventas} para que sea más accesible al público.

\end{itemize}

\section{Desarrollo de la Aplicación Móvil}

La app está diseñada para dispositivos con versiones Android 2.3 (Gingerbread) y superiores, hasta la versión actual 4.4 (KitKat). Esto es debido a que la versión 2.3, que salió en el año 2010, a día de hoy representa un 16.2\% de los dispositivos Android totales \cite{DespliegueAndroid}; no darles soporte para que puedan utilizar la app hubiese sido un error. Esto ha tenido diversas consecuencias que se especificarán durante el desarrollo de los siguientes apartados.

\subsection{Estructura}

La app está dividida en 3 paquetes: uno principal con las clases de cada una de las secciones, otro para gestionar lo referente a la cuenta de usuario y otro misceláneo.

\subsubsection{Paquete principal: es.ucm.myconference}

Este paquete contiene:

\begin{itemize}
    \item La que se podría considerar la clase principal - \texttt{NavigationDrawerActivity} - se encuentra en este paquete, que se encarga de crear el menú lateral desde el que se accede a cada sección de la app y la que gestiona el cambio entre dichas secciones, pasándoles la información necesaria para su uso. Esta clase gestiona el guardado del estado de la app por posibles eventos externos que pudiesen ocurrir, como un giro en la pantalla, una llamada o el apagado del dispositivo. Este estado se recupera al volver a mostrarse la app. El diagrama UML con los atributos y métodos de esta clase junto con la relación con otras clases se muestra en la figura ~\ref{fig:importantClass}

    \item Observadores para que cuando se produzca algún cambio en la base de datos referente al ingreso o borrado de un congreso, se actualice el menú.

    \item Una clase (Fragmento) para cada apartado dentro de la app:

    \begin{itemize}
        \item What's new -  Muestra las últimas noticias relacionadas con el congreso en formato de lista, con la fecha de publicación, un título y una breve descripción.
        \item Call for papers - Es un enlace a un archivo pdf con los temas sobre los que deben ir las presentaciones de los conferenciantes.
        \item Organising Committee - Dividido en una lista por categorías, es un listado de todos los conferenciantes que van a participar, listando su nombre y procedencia.
        \item Keynote Speakers - Son los ponentes principales y, por tanto, se les lista en un apartado diferente al resto. Incluímos una foto, una descripción y su procedencia y área de estudio.
        \item Conference Venue - Un listado de las direcciones de los lugares donde se van a celebrar las diferentes presentaciones y un mapa con la ubicación exacta. Si se desea, se puede seleccionar un lugar y buscar en Google Maps el trayecto hasta él.
        \item Travel Information - Una pequeña introducción a la ciudad y/o el país donde se celebra el congreso.
        \item Conference Program - El programa del congreso, con una lista con los horarios de cada presentación y el lugar donde se celebra.
        \item Links - Enlaces de interés que abren el navegador y redireccionan a una página web.
        \item About - Una descripción del congreso en sí y sobre su propósito. 
    \end{itemize}

    Todos estos fragmentos se encargan de realizar consultas a la base de datos y mostrar los resultados de una manera ordenada. Para ello utilizan algunas clases que se encuentran en el paquete misceláneo, que se detalla más adelante.

    \item Las clases para el registro y el logueo del usuario a través de la API. En la respuesta a la llamada se encuentran todos los tokens necesarios para mantener logueado al usuario y poder volver a loguearlo si la sesión ha caducado. Estos tokens junto con información del email y un ID se guardan globalmente para su uso desde otras clases.

    \item La actividad con la que empieza la aplicación, que es la pantalla de inicio con el nombre del congreso y su logotipo.

\end{itemize}

Un diagrama de cómo están relacionadas estas clases se puede ver en la figura ~\ref{fig:relationsPrincipal}. 

\figura{Vectorial/Android/importantClass}{width=\textwidth}{fig:importantClass}%
    {Diagrama UML de la clase \texttt{NavigationDrawerActivity}.}

\subsubsection{Paquete cuenta del usuario: es.ucm.myconference.accountmanager}

Este paquete contiene la lógica más compleja de la aplicación. En él se encuentran las clases para la gestión de cuentas de usuario y la gestión de la base de datos interna del dispositivo.

Para la gestión de la cuenta del usuario hemos utilizado unas clases que nos da Android para su gestión y almacenamiento \cite{AndroidAuth}. Cuando un usuario se registra, no solo lo hace a través de nuestra API y queda almacenado en nuestro servidor y base de datos, sino que también queda sincronizada esa cuenta con el teléfono. Desde la pantalla de Ajustes de su dispositivo, el usuario puede ver su cuenta de \textit{MyConference} y activar/desactivar la sincronización para recibir nuevos datos. Para poder realizar esto hemos tenido que implementar varias clases que se encuentran en este paquete:

\begin{itemize}
    \item \texttt{AccountAuthenticator} - El encargado de añadir una nueva cuenta al sistema y guardar el token de autorización (Auth token).
    \item \texttt{AccountAuthenticatorActivity} - La única interacción con el usuario. Presenta una pantalla donde el usuario introduce su email y una contraseña, y se comprueba que efectivamente lo que ha escrito es una dirección de email correcta y que la contraseña tiene mínimo 8 caracteres. Si todo va bien y el usuario se registra correctamente se guarda la cuenta con su token de autorización y se entra en la aplicación.
    \item \texttt{AuthenticatorService} - Servicio a través del cual nos comunicamos con el autenticador.
\end{itemize}

Para crear y gestionar la base de datos interna del dispositivo, que no tiene nada que ver con la base de datos global de MyConference, a la cual se accede a través de la API, hemos incluído varias clases. Por un lado la clase - \texttt{SyncAdapter} - que se encarga de guardar todos los datos que se reciben a través de la API en las distintas tablas de la base de datos interna. De esta forma la app tiene siempre una ``copia''  de los datos y no tiene que estar accediendo a la base de datos global cada vez que se quiere mostrar algo. Esto consumiría mucha batería y, lo que es peor, la tarifa de datos del usuario. Solo se sincronizará con la API cuando el usuario pulse el botón de Actualizar.

En la figura ~\ref{fig:accountManager} se puede ver un diagrama UML de este paquete.

El resto de clases para gestionar la base de datos interna se explican en la sección ~\ref{sec:basedatosinterna}.

\figura{Vectorial/Android/relationsPrincipal}{width=\textwidth}{fig:relationsPrincipal}%
    {Relación entre las clases del paquete es.ucm.myconference.}

\subsubsection{Paquete miscelánea: es.ucm.myconference.util}

Este paquete contiene:

\begin{itemize}
    \item Clases Adapter: A la hora de mostrar los datos, las clases predefinidas de Android pueden llegar a ser limitadas en cuanto a la relación de qué datos le envío y cómo queremos que los muestre. A veces es necesario heredar de una clase base e implementar sus métodos a nuestro gusto. En este paquete se encuentran esas clases para varias de las secciones, que se denominan \textit{adapters}.


    \item Para la gestión de las descripciones de los ponentes principales utilizamos 2 clases, para que el \textit{look\&feel} sea mejor. Estas clases se encargan de colocar el texto alrededor de una imagen y que no quede todo descentrado.

    \item Una clase para almacenar constantes y así tenerlas en un sitio común, y otra clase para datos estáticos, como son los iconos del menú lateral.
\end{itemize}

\figuraEx{Vectorial/Android/accountManager}{width=\textwidth}{fig:accountManager}%
    {Diagrama UML de las clases del paquete es.ucm.myconference.accountmanager.}{UML del paquete es.ucm.myconference.accountmanager}

\subsection{Librerías externas}

Aparte de las librerías propias de Android, hemos utilizado las siguientes librerías externas:

\begin{itemize}
	\item \textit{ActionBarSherlock} para poder conseguir el aspecto de una app actual en versiones anteriores a la 3.0 (Honeycomb)
    \cite{ABS}.
    \item \textit{Amazing List View} para conseguir un aspecto bonito y sencillo para el programa de las conferencias
    \cite{AmazingListView}.
    \item También se ha utilizado \textit{Google Play Services} para poder usar la aplicación de Google Maps dentro de nuestra app.
\end{itemize}

\begin{figure}[ht!]
\centering
\includegraphics[width=0.8\textwidth]%
                {./Imagenes/Vectorial/Android/actionBarSherlock}
\caption{\textit{Action Bar} en nuestra app gracias a \texttt{ActionBarSherlock}}
\label{fig:actionBarSherlock}
\end{figure}

\subsubsection{ActionBarSherlock}

Con la llegada de la versión de Android 3.0 (Honeycomb) se introdujo un nuevo elemento a la interfaz de usuario de las apps: la \textit{Action Bar}. Este elemento proporciona al usuario su localización dentro de la aplicación, así como acceso a las acciones de usuario y modos de navegación. Como nuestra app ha sido diseñada para ser compatible con versiones desde la 2.3 ha sido necesario añadir una librería para poder implementarla. Hemos escogido la librería \texttt{ActionBarSherlock} por ser una de las más extendidas y, por tanto, mayor documentación y resolución de problemas por parte de la comunidad de desarrolladores. Otra opción hubiese sido desarrollar nuestra app sin este elemento, pero queríamos que se pareciese lo máximo posible al diseño de una app para las últimas versiones, que es lo que el usuario quiere. No una interfaz anticuada y obsoleta.

En la \textit{Action Bar} incluímos el título de la sección actual por la que se navega y un menú para desconectarse de la app. Presionando en el logo de la app se abre el menú lateral con una lista de todas las secciones disponibles. Además, si el menú lateral está abierto, se muestra el botón de actualizar para cargar nuevos datos a la base de datos interna del dispositivo. En la figura ~\ref{fig:actionBarSherlock} se puede ver el aspecto final.

\paragraph{Uso}

Para poder utilizar \texttt{ActionBarSherlock} dentro de nuestra app tuvimos que hacer dos cosas:

\begin{itemize}
	\item Crear una clase abstracta \texttt{MyConferenceActivity} que extendiera a la clase \linebreak\texttt{SherlockFragmentActivity}.
	\item Crear una clase \texttt{MyConferenceFragment} que extendiera a \texttt{SherlockFragment}.
\end{itemize}

A partir de ese momento, cualquier actividad que se creara extendería a la clase \linebreak\texttt{MyConferenceActivity} y cualquier fragmento de \texttt{MyConferenceFragment}. Esto hacía que automáticamente se introdujese la \textit{Action Bar} en la interfaz gráfica.

Para obtener una referencia a la \textit{Action Bar} solo era necesario llamar al método \linebreak\texttt{getSupportActionBar()}, como si se utilizara la que viene con la librería de soporte, ya que \texttt{ActionBarSherlock} sobreescribe ese método y nos devuelve la suya. El resto de código utilizado ha sido habilitar el botón de ``home'', situado en la esquina izquierda de la barra, utilizando la función \texttt{setHomeButtonEnabled(true)}; y realizar una llamada a la función \texttt{setDisplayHomeAsUpEnabled(true)} para poder mostrar el icono de abertura y cierre del menú lateral. También hemos utilizado la función \texttt{setTitle(String title)} para poder cambiar el título al de la sección actual en la que nos encontráramos.

\begin{figure}[h]
\centering
\includegraphics[width=0.5\textwidth,height=11cm]%
                {Imagenes/Vectorial/Android/amazingListView}
\caption[Agenda de un congreso con \texttt{AmazingListView}]{Pantalla de la aplicación que muestra la agenda de un congreso}
\label{fig:amazingListView}
\end{figure}

\subsubsection{AmazingListView}

La forma más clara de mostrar el programa de un congreso es hacerlo con una lista ordenada por días y, dentro de cada día, el horario programado para cada conferencia. Las listas por defecto de Android son bastante simples a la hora de mostrar los datos de manera elegante, así que buscamos una librería externa para darle un aspecto más profesional. Con la librería \texttt{AmazingListView} hemos sido capaces de poner la fecha como título para cada una de las conferencias que se desarrollen ese día, y que este título sea visible hasta que aparezca en pantalla el siguiente día. Es una buena forma de no perder de vista la fecha en una lista larga de eventos.

\paragraph{Uso}

A la hora de incluir esta librería en nuestro proyecto hemos tenido que crear varios archivos que, aunque no ha sido difícil, si ha sido un proceso laborioso, porque hay que ir con cuidado y paso a paso para no equivocarse. Por suerte para nosotros, era una librería que habíamos utilizado en un proyecto anterior como prueba a esta app de \texttt{MyConference}, y teníamos una buena base.

\begin{itemize}
	\item Se crearon 3 archivos XML para la interfaz gráfica. El principal contenía simplemente la definición de un widget de \texttt{AmazingListView} con una lista como elemento. Los otros 2 eran el aspecto visual que tendrían las cabeceras de cada sección de la lista y los elementos de la lista en si. En nuestro caso existe una cabecera por cada día de duración del congreso, y cada elemento de la lista contiene una hora de comienzo, un título y una descripción.
	\item Se creó un fragmento denominado \texttt{ProgramFragment} que albergaba la lógica básica de unir cada archivo XML y la consecución de los datos a mostrar.
	\item Se creó un \texttt{AmazingSimpleCursorAdapter} que gestionaba el orden de los elementos, cuáles iban con qué cabeceras y las transiciones entre cabeceras. Esta es la clase más ``liosa'' porque es la que hay que retocar si algo no se muestra como se esperaba.
\end{itemize}

En la figura ~\ref{fig:amazingListView} se puede ver el aspecto con el que la aplicación presenta la agenda de un congreso. Esta forma de mostrar una lista la hemos podido conseguir utilizando \texttt{AmazingListView}.

\begin{figure}[h]
\centering
\includegraphics[width=0.5\textwidth,height=11cm]%
                {Imagenes/Vectorial/Android/googleMaps}
\caption[Pantalla de la aplicación con los lugares relevantes de un congreso.]{Pantalla de la sección de lugares utilizando \textit{Google Maps}}
\label{fig:googleMaps}
\end{figure}

\subsubsection{Google Maps APIv2}

Para mostrar la localización de los lugares relevantes del congreso (hoteles, donde se celebran las conferencias...) hemos utilizado Google Maps, incluyendo un pequeño mapa dentro de nuestra app con un marcador en cada sitio. 

Al principio añadimos una lista de lugares, cada uno con un enlace que abría la propia aplicación de Google Maps instalada en el dispositivo para mostrar su ubicación, pero decidimos aprovechar que se podía incluir en la propia app para que de manera clara y de un vistazo se pudiesen ver todos los lugares. Actualmente, la aplicación permite las dos cosas. Por un lado el mapa completo con todos los lugares de interés y por otro el listado para que el usuario pueda utilizar las funciones más avanzadas de los mapas, como el creado de una ruta desde su posición hasta la ubicación del congreso. En la figura ~\ref{fig:googleMaps} se puede ver como queda esta pantalla.

\paragraph{Uso}

Para poder utilizar los mapas es necesario incluir la librería \textit{Google Play Services} así como disponer de una API Key única para la app. Es una tarea un poco compleja, pero existe un buen tutorial en la página de desarrolladores de Android \cite{TutorialGoogleMaps}.

En la clase creada para añadir el mapa hace falta un objeto del tipo \texttt{GoogleMap} al que se le asigna un mapa llamando a la función \texttt{getMap()}. A partir de aquí queda únicamente la configuración del mapa.

Lo primero que tuvimos que hacer para la configuración del mapa fue añadir un marcador por cada lugar existente en la base de datos. Cuando un usuario pincha sobre el marcador, aparece una ventana de información con el nombre del lugar y si se pincha en esa ventana, lanzamos un \texttt{Intent} para abrir la aplicación de Google Maps instalada en el dispositivo con ese lugar pinchado como origen. Si el usuario no tuviese instalada la aplicación simplemente se muestra un mensaje de error en forma de \texttt{Toast} comentando que no ha sido posible abrir el mapa.

Y el siguiente paso era centrar el mapa en la ciudad donde se vaya a celebrar el congreso, para así ver todos los marcadores juntos. La API de Google Maps es bastante completa y está bien documentada, así que se pueden conseguir buenos efectos de transición llamando a dos o tres funciones. En nuestro caso creamos un objeto de tipo \texttt{CameraPosition} para fijar el lugar donde se tenía que situar la cámara y el zoom que se tenía que aplicar sobre la región, y llamar a la función \texttt{animateCamera()} que se encarga de una transición suave y agradable a la vista.

\section{Base de datos interna}
\label{sec:basedatosinterna}

En la etapa de planificación de la app para Android sabíamos que tenía que haber una base de datos en el dispositivo para almacenar todos los datos que recibiríamos a través de la API. De no ser así, cada vez que el usuario abriese la app tendrían que descargarse todos los datos de nuevo para poder mostrarlos, y este comportamiento tiene varias desventajas:

\begin{enumerate}
	\item \textbf{Rendimiento}. Descargar todos los datos y mostrarlos puede ser un proceso lento, pues depende ya no solo de la cantidad de datos a descargar, sino de la velocidad de conexión a internet del usuario y de la velocidad de su dispositivo.
    \item \textbf{Batería}. Descargar datos de internet durante un tiempo prolongado o muchas veces en cortos períodos de tiempo suele agotar la batería del dispositivo más rápido, y no es de agrado para un usuario ver cómo se gasta su batería por usar nuestra app. La desinstalaría.
    \item \textbf{Consumo de datos}. Si no se está conectado por WIFI se utiliza la tarifa de datos que tenga contratada el usuario. Y eso es dinero que no se puede malgastar cada vez que se abre una app.
\end{enumerate}

La forma lógica de atacar el problema era crear una base de datos local y que el usuario decidiera cuándo quería actualizar la información de la que disponía si hubiesen nuevos datos, excepto la primera vez que se abre la app que se tiene que descargar todo. Así, aunque el usuario no disponga conexión a internet, ya tiene en su dispositivo toda la información almacenada para su consulta.

Para la creación y gestión de bases de datos Android incorpora una librería denominada SQLite que utiliza el lenguaje SQL de una forma sencilla y utilizando muy pocos recursos del sistema. 

La base de datos se organiza en tablas. Cada tabla se compone de filas y columnas. Las filas se corresponden con los registros y las columnas son los campos.

Siguiendo el ejemplo disponible en la página de desarrolladores de Android hemos creado una base de datos con las siguientes tablas \cite{BaseDatosAndroid}:
\begin{itemize}
	\item Congresos
	\item Documentos
	\item Lugares
	\item Anuncios
	\item Ponentes principales
	\item Comité organizador
    \item Agenda
\end{itemize}

Todas las tablas tienen los campos comunes siguientes: la primera columna \texttt{ID} de tipo entero y autoincremental. Esto quiere decir que cada vez que se inserta un registro se le asigna un id diferente; y la segunda columna denominada \texttt{conf\_uuid}, que es el identificador propio de cada congreso, ya que dentro de la app puede haber varios congresos a los que el usuario vaya a asistir y, por ejemplo, todos los anuncios se guardan en la misma tabla, y tiene que poderse diferenciar a qué congreso pertenece cada anuncio. Este identificador se consigue a partir de la tabla de \textit{Congresos}, cuyos campos se explican en la siguiente sección.

El resto de campos son propios de cada tabla:

\paragraph{Congresos}

Se compone de 3 campos: el nombre del congreso, una descripción que luego se mostrará en la sección \textit{About} de la app, y el campo date con la fecha de creación. Los 3 campos son de tipo \texttt{TEXT}.

\begin{center}
    \begin{tabular}{|c | c | c | c | c| }
        \hline
        \_id & conf\_uuid & title & description & date \\
        \hline
        INTEGER & TEXT & TEXT & TEXT & TEXT \\
        \hline
    \end{tabular}
\end{center}

\paragraph{Documentos}

Esta tabla está pensada para posibles \texttt{.pdf} o \texttt{.doc} que se suban de manera informativa. Contiene los campos título, descripción, el tipo que tiene el archivo y datos, que es el archivo en si. Todos los campos son de tipo \texttt{TEXT}.

\begin{center}
    \begin{tabular}{|c | c | c | c | c | c| }
        \hline
        \_id & conf\_uuid & title & description & type & data \\
        \hline
        INTEGER & TEXT & TEXT & TEXT & TEXT & TEXT \\
        \hline
    \end{tabular}
\end{center}

\paragraph{Lugares}

Se guarda el nombre y una breve descripción de tipo \texttt{TEXT}. La descripción suele ser la dirección completa de la ubicación. También se almacena como dato de tipo \texttt{REAL} la latitud y la longitud, que nos sirven para posicionar los marcadores en el mapa de Google Maps.

\begin{center}
    \begin{tabular}{|c | c | c | c | c | c| }
        \hline
        \_id & conf\_uuid & name & lat & lng & details \\
        \hline
        INTEGER & TEXT & TEXT & REAL & REAL & TEXT \\
        \hline
    \end{tabular}
\end{center}

\paragraph{Anuncios}

Los anuncios son pequeños textos dónde se resume algún evento o novedad importante. Para ello se almacena un título, un cuerpo del anuncio y la fecha en que se publica el anuncio. A la hora de mostrarlos se ordenan por fecha del más reciente al más antiguo. Todos los campos son de tipo \texttt{TEXT}.

\begin{center}
    \begin{tabular}{|c | c | c | c | c| }
        \hline
        \_id & conf\_uuid & title & body & date \\
        \hline
        INTEGER & TEXT & TEXT & TEXT & TEXT \\
        \hline
    \end{tabular}
\end{center}

\paragraph{Ponentes principales}

Como requieren más información que otros ponentes o que los organizadores, se almacenan en una tabla aparte. Sus campos son: el nombre, el cargo que desempeña en su vida profesional, el lugar del que proviene, una descripción de su actividad, una foto y, opcionalmente, uno o varios links a páginas personales. Todos los campos son de tipo \texttt{TEXT}.

\begin{center}
    \begin{tabular}{|c | c | c | c | c | c | c | c| }
        \hline
        \_id & conf\_uuid & name & charge & origin & description & picture\_url & links \\
        \hline
        INTEGER & TEXT & TEXT & TEXT & TEXT & TEXT & TEXT & TEXT \\
        \hline
    \end{tabular}
\end{center}

\paragraph{Comité organizador}

Esta tabla es la más poblada ya que hay mucha gente detrás de la organización de un congreso. Se almacena su nombre, la ciudad o país de donde proviene, una breve descripción si la hay y el grupo al que pertenece dentro del comité, que se utiliza como cabecera a la hora de mostrarlos dentro de la app.

\begin{center}
    \begin{tabular}{|c | c | c | c | c | c| }
        \hline
        \_id & conf\_uuid & name & origin & details & groups \\
        \hline
        INTEGER & TEXT & TEXT & TEXT & TEXT & TEXT \\
        \hline
    \end{tabular}
\end{center}

\paragraph{Agenda}

En ella se almacena el programa del congreso, donde cada conferencia tiene un título, una descripción y su fecha (día y hora).

\begin{center}
    \begin{tabular}{|c | c | c | c | c| }
        \hline
        \_id & conf\_uuid & title & description & date \\
        \hline
        INTEGER & TEXT & TEXT & TEXT & TEXT \\
        \hline
    \end{tabular}
\end{center}

Para gestionar la base de datos existen 2 clases en el paquete \texttt{es.ucm.myconference.accountmanager}:

\begin{itemize}
	\item \texttt{SqlHelper}, que extiende a SQLiteOpenHelper. Es la clase que se encarga de crear las tablas de la base de datos cuando se instala la app en el dispositivo. Al crear la base de datos se le da un nombre y una versión, que se va incrementando a medida que se van añadiendo nuevas tablas.

    A través de comandos SQL se crean los diferentes campos de las tablas y se les asigna un tipo: \texttt{TEXT} para texto y \texttt{REAL} o \texttt{INT} para números. No nos ha hecho falta ningún tipo más pues la inmensa mayoría es texto. Esto hace que la base de datos no sea demasiado pesada.

    Asimismo, esta clase se encarga de actualizar la base de datos cuando una nueva versión está disponible.
    \item \texttt{ConfsProvider}, que extiende a ContentProvider. Cuando se accede a la base de datos para una búsqueda o una inserción nueva, ésta es la clase que lo gestiona. \texttt{ContentProvider} se traduce como Proveedor de Contenidos.

    Para poder acceder al contenido de la base de datos es necesario que esté identificado, y eso se hace a través de las URIs. Una URI
    es una cadena de texto que permite identificar un recurso de información. Lo primero que se hace es asignar dos URIs a cada una de las tablas de la base de datos: una para realizar consultas de un solo registro y otra para varios. También se asigna un tipo para cada URI, dependiendo si es individual o colectiva. Y a continuación están los métodos que se encargan de las consultas, inserciones, borrados y actualizaciones de registros.

    Los \texttt{ContentProvider} utilizan una clase denominada \texttt{Cursor} para devolver los resultados de las consultas. Son colecciones que se recorren de la misma manera que el patrón \textit{iterator}, y que utilizan los adapters para mostrar los datos.
    Las inserciones devuelven la URI del nuevo registro almacenado, y los borrados y actualizaciones devuelven el número de registros afectados.
\end{itemize}


\section{SharedPreferences}

Android ofrece otra forma de guardar datos de manera persistente cuando instalamos una app, y son las SharedPreferences.

Esta información se almacena de manera privada, de modo que solo nuestra app puede acceder a ella. Son pares clave-valor cuyos tipos sólo pueden ser booleans, floats, ints, longs, y strings. 

En nuestro caso utilizamos este tipo de almacenamiento para guardar el nombre del usuario, el email, su identificador, y los tokens de acceso y refresco que nos proporciona la API al registrarse o hacer login en la app. También se utiliza durante la aplicación para almacenar si el usuario se desloguea de la app antes de salir o para saber si es la primera vez que accede a la app.

Si el usuario sale de la app sin desloguearse, al volver a entrar aparecerá en la pantalla inicial. Si por el contrario pulsa en Logout para salir, al entrar se le solicitarán los credenciales.

Almacenar un booleano indicando si es la primera vez que entra en la app lo utilizamos para mostrar el menú lateral durante un período de tiempo, según la guía de diseño de Android. \cite{DisenioAndroid}

\section{Permisos}

Al instalar una app Android en un dispositivo se muestran los distintos permisos que necesita el usuario aceptar para que la aplicación pueda funcionar. 

Para nuestra app hacen falta los siguientes permisos:

\begin{itemize}
	\item INTERNET. Es necesario poder conectarse a internet para la descarga de los datos desde nuestra base de datos al dispositivo y para descargar los mapas de Google Maps.
	\item READ\textbackslash WRITE\_SYNC\_SETTINGS. Permite leer y controlar las opciones de sincronización. Se utiliza, por ejemplo, para sincronizaciones periódicas o para ver si en un momento determinado se puede sincronizar con el servidor.
	\item AUTHENTICATE\_ACCOUNTS. Se utiliza para poder autenticar la cuenta de usuario que creamos en el dispositivo.
	\item GET\_ACCOUNTS. Al iniciar una sincronización es necesario localizar la cuenta de usuario desde la que se manda la petición.
	\item ACCESS\_NETWORK\_STATE. Permite a la API de Google Maps saber el estado de la conexión para ver si es posible descargar la información.
	\item READ\_GSERVICES. Da acceso a los servicios web de Google.
	\item ACCESS\_COARSE\_LOCATION. Se utiliza para permitir que se localice la posición del dispositivo, ya sea por WIFI o por la red de datos.
	\item ACCESS\_FINE\_LOCATION. Para espacios más reducidos, poder utilizar el GPS para posicionar el dispositivo.
	\item WRITE\_EXTERNAL\_STORAGE. Utilizado por los mapas de Google Maps para cachear los mapas en la memoria externa del dispositivo.
\end{itemize}

También es necesario incluir que se utiliza OpenGL para los mapas en su versión 2. Sin esto en el dispositivo no se visualizarán los mapas.

Todos estos permisos se incluyen en \texttt{AndroidManifest.xml}, archivo obligatorio en toda app de Android  que contiene información de la misma necesaria para el sistema.
